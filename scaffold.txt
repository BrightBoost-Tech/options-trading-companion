## FILE TREE
options-trading-companion/
├── .gitignore
├── .env.example
├── package.json
├── pnpm-workspace.yaml
├── tsconfig.json
├── README.md
├── apps/
│   ├── web/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   ├── next.config.js
│   │   ├── tailwind.config.ts
│   │   ├── postcss.config.js
│   │   ├── middleware.ts
│   │   ├── env.ts
│   │   ├── app/
│   │   │   ├── layout.tsx
│   │   │   ├── page.tsx
│   │   │   ├── (auth)/
│   │   │   │   ├── login/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── signup/
│   │   │   │       └── page.tsx
│   │   │   └── (protected)/
│   │   │       ├── dashboard/
│   │   │       │   └── page.tsx
│   │   │       ├── journal/
│   │   │       │   └── page.tsx
│   │   │       ├── compose/
│   │   │       │   └── page.tsx
│   │   │       └── settings/
│   │   │           └── page.tsx
│   │   ├── components/
│   │   │   ├── PositionsTable.tsx
│   │   │   ├── RiskBar.tsx
│   │   │   ├── GuardrailList.tsx
│   │   │   ├── CandidateForm.tsx
│   │   │   ├── QuantumCompare.tsx
│   │   │   ├── AlertBell.tsx
│   │   │   └── ui/
│   │   │       ├── button.tsx
│   │   │       ├── card.tsx
│   │   │       ├── input.tsx
│   │   │       └── badge.tsx
│   │   └── lib/
│   │       ├── client/
│   │       │   ├── supabase.ts
│   │       │   └── queries.ts
│   │       └── formatters.ts
│   └── worker/
│       ├── package.json
│       ├── wrangler.toml
│       ├── src/
│       │   ├── index.ts
│       │   ├── cron.ts
│       │   └── webhooks.ts
│       └── tsconfig.json
├── packages/
│   ├── core/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── index.ts
│   │       ├── schemas.ts
│   │       ├── gate.ts
│   │       └── types.ts
│   ├── server/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── index.ts
│   │       ├── rpc.ts
│   │       └── auth.ts
│   ├── data/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── index.ts
│   │       ├── websocket.ts
│   │       ├── snapshot.ts
│   │       └── features.ts
│   ├── ai/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── src/
│   │       ├── index.ts
│   │       ├── client.ts
│   │       ├── prompts.ts
│   │       └── tools.ts
│   ├── risk/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   ├── engine.ts
│   │   │   ├── evaluator.ts
│   │   │   └── backtest.ts
│   │   └── profiles/
│   │       ├── credit_put_spread_core.yaml
│   │       └── iron_condor_safe.yaml
│   └── quantum/
│       ├── package.json
│       ├── requirements.txt
│       ├── optimizer.py
│       └── test_optimizer.py
└── infra/
    ├── supabase/
    │   ├── config.toml
    │   └── migrations/
    │       ├── 20240101000000_initial_schema.sql
    │       ├── 20240101000001_rls_policies.sql
    │       └── 20240101000002_seed_data.sql
    ├── cloudflare/
    │   └── .gitkeep
    ├── vercel/
    │   └── vercel.json
    └── scripts/
        ├── bootstrap.sh
        ├── env-check.ts
        └── dev-run.sh
## CODE FILES --- path: .gitignore
# dependencies
node_modules/
.pnp
.pnp.js

# testing
coverage/

# next.js
.next/
out/
build
dist/

# misc
.DS_Store
*.pem
.env
.env*.local
.vercel
.wrangler

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# python
__pycache__/
*.py[cod]
*$py.class
.venv/
venv/
*.egg-info/

# IDEs
.idea/
.vscode/
*.swp
*.swo
--- path: .env.example
# Anthropic AI
ANTHROPIC_API_KEY=sk-ant-xxx

# Broker Aggregator
SNAPTRADE_API_KEY=your-snaptrade-key
SNAPTRADE_CLIENT_ID=your-client-id

# Market Data
MARKETDATA_API_KEY=your-polygon-or-massive-key

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Cloudflare
CF_ACCOUNT_ID=your-account-id
CF_API_TOKEN=your-api-token

# Web Push
NEXT_PUBLIC_PUSH_PUBLIC_KEY=your-push-public-key
PUSH_PRIVATE_KEY=your-push-private-key

# App Config
NEXT_PUBLIC_APP_URL=http://localhost:3000
NODE_ENV=development
--- path: package.json
json
{
  "name": "options-trading-companion",
  "version": "1.0.0",
  "private": true,
  "description": "Personal options trading companion with AI-powered scouting and guardrails",
  "scripts": {
    "dev": "pnpm --parallel --filter \"./apps/**\" dev",
    "build": "pnpm --filter \"./packages/**\" build && pnpm --filter \"./apps/**\" build",
    "test": "vitest",
    "lint": "eslint .",
    "type-check": "tsc --noEmit",
    "bootstrap": "bash infra/scripts/bootstrap.sh",
    "env-check": "tsx infra/scripts/env-check.ts"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "eslint": "^8.55.0",
    "eslint-config-next": "^14.0.4",
    "prettier": "^3.1.1",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^1.1.0"
  },
  "engines": {
    "node": ">=18.0.0",
    "pnpm": ">=8.0.0"
  }
}
--- path: pnpm-workspace.yaml
yaml
packages:
  - 'apps/*'
  - 'packages/*'
--- path: tsconfig.json
json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": false,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "incremental": true,
    "paths": {
      "@core/*": ["./packages/core/src/*"],
      "@server/*": ["./packages/server/src/*"],
      "@data/*": ["./packages/data/src/*"],
      "@ai/*": ["./packages/ai/src/*"],
      "@risk/*": ["./packages/risk/src/*"]
    }
  },
  "exclude": ["node_modules", ".next", "dist", "build"]
}
--- path: README.md
markdown
# Options Trading Companion MVP

Production-ready personal options trading app with AI-powered scouting, guardrails learning, and quantum portfolio optimization.

## Features

- **Read-only broker integration** via SnapTrade aggregator
- **Live market data** streaming with feature extraction
- **AI Trade Scout** using Claude Sonnet 4.5 with prompt caching
- **Candidate validation** with strict gating rules
- **Loss review system** that learns guardrails automatically
- **Quantum optimizer** (mean-variance-skew) - simulator mode
- **Low monthly cost** on managed SaaS (Vercel + Supabase + Cloudflare)

## Tech Stack

- Frontend: Next.js 14, TypeScript, Tailwind, TanStack Query
- Backend: Supabase (Postgres + Edge Functions)
- Jobs: Cloudflare Workers
- AI: Anthropic Claude API
- Market Data: Polygon/Massive aggregator
- Quantum: Python (NumPy/SciPy)

## Quick Start

See RUN LOCALLY section at the end of this file.

## Architecture

- Strict JSON I/O for all LLM interactions
- Gating rules run BEFORE any LLM call
- Prompt caching enabled for cost optimization
- RLS policies enforce user data isolation
- Debounced trade scouting with monthly LLM budget cap

## License

Private use only.
--- path: apps/web/package.json
json
{
  "name": "@app/web",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@core/types": "workspace:*",
    "@supabase/ssr": "^0.1.0",
    "@supabase/supabase-js": "^2.39.0",
    "@tanstack/react-query": "^5.17.0",
    "next": "14.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3"
  }
}
--- path: apps/web/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"],
      "@core/*": ["../../packages/core/src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
--- path: apps/web/next.config.js
javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  experimental: {
    serverActions: true,
  },
  transpilePackages: ['@core/types'],
  env: {
    NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY,
  },
};

module.exports = nextConfig;
--- path: apps/web/tailwind.config.ts
typescript
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--foreground))',
        },
        success: '#10b981',
        danger: '#ef4444',
        warning: '#f59e0b',
      },
    },
  },
  plugins: [],
};

export default config;
--- path: apps/web/postcss.config.js
javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
--- path: apps/web/middleware.ts
typescript
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({
            name,
            value,
            ...options,
          });
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({
            name,
            value: '',
            ...options,
          });
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Protected routes
  if (request.nextUrl.pathname.startsWith('/dashboard') ||
      request.nextUrl.pathname.startsWith('/journal') ||
      request.nextUrl.pathname.startsWith('/compose') ||
      request.nextUrl.pathname.startsWith('/settings')) {
    if (!user) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
  }

  // Redirect authenticated users away from auth pages
  if ((request.nextUrl.pathname === '/login' || request.nextUrl.pathname === '/signup') && user) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return response;
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
};
--- path: apps/web/env.ts
typescript
import { z } from 'zod';

const envSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  NEXT_PUBLIC_APP_URL: z.string().url().default('http://localhost:3000'),
  NEXT_PUBLIC_PUSH_PUBLIC_KEY: z.string().optional(),
});

export const env = envSchema.parse({
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,
  NEXT_PUBLIC_PUSH_PUBLIC_KEY: process.env.NEXT_PUBLIC_PUSH_PUBLIC_KEY,
});
--- path: apps/web/app/layout.tsx
typescript
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { QueryProvider } from '@/lib/client/query-provider';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Options Trading Companion',
  description: 'AI-powered options trading companion',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <QueryProvider>{children}</QueryProvider>
      </body>
    </html>
  );
}
--- path: apps/web/app/globals.css
css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --border: 214.3 31.8% 91.4%;
  --primary: 222.2 47.4% 11.2%;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --primary: 210 40% 98%;
  }
}

* {
  box-sizing: border-box;
}

body {
  color: hsl(var(--foreground));
  background: hsl(var(--background));
}
--- path: apps/web/app/page.tsx
typescript
import Link from 'next/link';

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <div className="max-w-2xl text-center">
        <h1 className="text-5xl font-bold mb-6">Options Trading Companion</h1>
        <p className="text-xl text-gray-600 mb-8">
          AI-powered trade scouting with automated guardrail learning
        </p>
        <div className="flex gap-4 justify-center">
          <Link
            href="/login"
            className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Login
          </Link>
          <Link
            href="/signup"
            className="px-6 py-3 border border-gray-300 rounded-lg hover:bg-gray-50"
          >
            Sign Up
          </Link>
        </div>
      </div>
    </main>
  );
}
--- path: apps/web/app/(auth)/login/page.tsx
typescript
'use client';

import { useState } from 'react';
import { createBrowserClient } from '@supabase/ssr';
import { useRouter } from 'next/navigation';
import { env } from '@/env';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const router = useRouter();

  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) {
      setError(error.message);
    } else {
      router.push('/dashboard');
      router.refresh();
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-md space-y-8">
        <div>
          <h2 className="text-3xl font-bold text-center">Sign in</h2>
        </div>
        <form onSubmit={handleLogin} className="space-y-6">
          {error && (
            <div className="p-3 text-sm text-red-600 bg-red-50 rounded">
              {error}
            </div>
          )}
          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              required
            />
          </div>
          <button
            type="submit"
            className="w-full py-2 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Sign in
          </button>
        </form>
      </div>
    </div>
  );
}
--- path: apps/web/app/(auth)/signup/page.tsx
typescript
'use client';

import { useState } from 'react';
import { createBrowserClient } from '@supabase/ssr';
import { useRouter } from 'next/navigation';
import { env } from '@/env';

export default function SignupPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const router = useRouter();

  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    const { error } = await supabase.auth.signUp({
      email,
      password,
    });

    if (error) {
      setError(error.message);
    } else {
      router.push('/dashboard');
      router.refresh();
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center px-4">
      <div className="w-full max-w-md space-y-8">
        <div>
          <h2 className="text-3xl font-bold text-center">Create account</h2>
        </div>
        <form onSubmit={handleSignup} className="space-y-6">
          {error && (
            <div className="p-3 text-sm text-red-600 bg-red-50 rounded">
              {error}
            </div>
          )}
          <div>
            <label className="block text-sm font-medium mb-2">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              required
            />
          </div>
          <div>
            <label className="block text-sm font-medium mb-2">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
              required
              minLength={6}
            />
          </div>
          <button
            type="submit"
            className="w-full py-2 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Sign up
          </button>
        </form>
      </div>
    </div>
  );
}
--- path: apps/web/app/(protected)/dashboard/page.tsx
typescript
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { PositionsTable } from '@/components/PositionsTable';
import { RiskBar } from '@/components/RiskBar';
import { AlertBell } from '@/components/AlertBell';
import { QuantumCompare } from '@/components/QuantumCompare';

export default async function DashboardPage() {
  const supabase = createServerComponentClient({ cookies });
  const {
    data: { user },
  } = await supabase.auth.getUser();

  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-7xl mx-auto space-y-6">
        <div className="flex justify-between items-center">
          <h1 className="text-3xl font-bold">Dashboard</h1>
          <AlertBell />
        </div>

        <RiskBar />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div className="lg:col-span-2">
            <PositionsTable />
          </div>
          <div>
            <QuantumCompare />
          </div>
        </div>
      </div>
    </div>
  );
}
--- path: apps/web/app/(protected)/journal/page.tsx
typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';
import { GuardrailList } from '@/components/GuardrailList';

export default function JournalPage() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const { data: trades } = useQuery({
    queryKey: ['trades'],
    queryFn: async () => {
      const { data } = await supabase
        .from('trades')
        .select('*')
        .order('close_ts', { ascending: false, nullsFirst: false });
      return data;
    },
  });

  const { data: lossReviews } = useQuery({
    queryKey: ['loss_reviews'],
    queryFn: async () => {
      const { data } = await supabase
        .from('loss_reviews')
        .select('*, trades(*)')
        .order('created_at', { ascending: false });
      return data;
    },
  });

  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-7xl mx-auto space-y-8">
        <h1 className="text-3xl font-bold">Journal</h1>

        <section>
          <h2 className="text-2xl font-semibold mb-4">Active Guardrails</h2>
          <GuardrailList />
        </section>

        <section>
          <h2 className="text-2xl font-semibold mb-4">Loss Reviews</h2>
          <div className="bg-white rounded-lg shadow">
            {lossReviews?.map((review) => (
              <div key={review.id} className="p-6 border-b last:border-b-0">
                <div className="flex justify-between mb-2">
                  <span className="font-medium">{review.trades?.symbol}</span>
                  <span className="text-sm text-gray-500">
                    {new Date(review.created_at).toLocaleDateString()}
                  </span>
                </div>
                <p className="text-gray-700 mb-2">
                  <strong>Root Cause:</strong> {review.root_cause}
                </p>
                <div className="text-sm text-gray-600">
                  Confidence: {(review.confidence * 100).toFixed(0)}%
                </div>
              </div>
            ))}
          </div>
        </section>

        <section>
          <h2 className="text-2xl font-semibold mb-4">Closed Trades</h2>
          <div className="bg-white rounded-lg shadow overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 border-b">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                    Symbol
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                    Open
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                    Close
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                    P&L %
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200">
                {trades?.filter(t => t.close_ts).map((trade) => (
                  <tr key={trade.id}>
                    <td className="px-6 py-4 whitespace-nowrap font-medium">
                      {trade.symbol}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                      {new Date(trade.open_ts).toLocaleDateString()}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                      {trade.close_ts ? new Date(trade.close_ts).toLocaleDateString() : '-'}
                    </td>
                    <td className={`px-6 py-4 whitespace-nowrap text-sm font-medium ${
                      trade.pnl_pct >= 0 ? 'text-green-600' : 'text-red-600'
                    }`}>
                      {trade.pnl_pct?.toFixed(2)}%
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </section>
      </div>
    </div>
  );
}
--- path: apps/web/app/(protected)/compose/page.tsx
typescript
'use client';

import { CandidateForm } from '@/components/CandidateForm';

export default function ComposePage() {
  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-4xl mx-auto space-y-6">
        <h1 className="text-3xl font-bold">Compose Trade</h1>
        <p className="text-gray-600">
          Enter your trade idea and get AI-powered validation with strict gating checks.
        </p>
        <CandidateForm />
      </div>
    </div>
  );
}
--- path: apps/web/app/(protected)/settings/page.tsx
typescript
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';
import { useState } from 'react';

export default function SettingsPage() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
  const queryClient = useQueryClient();

  const { data: settings } = useQuery({
    queryKey: ['settings'],
    queryFn: async () => {
      const { data: user } = await supabase.auth.getUser();
      const { data } = await supabase
        .from('settings')
        .select('*')
        .eq('user_id', user.data.user?.id)
        .single();
      return data;
    },
  });

  const updateSettings = useMutation({
    mutationFn: async (updates: any) => {
      const { data: user } = await supabase.auth.getUser();
      const { data } = await supabase
        .from('settings')
        .update(updates)
        .eq('user_id', user.data.user?.id)
        .select()
        .single();
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['settings'] });
    },
  });

  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="max-w-4xl mx-auto space-y-8">
        <h1 className="text-3xl font-bold">Settings</h1>

        <section className="bg-white rounded-lg shadow p-6 space-y-4">
          <h2 className="text-xl font-semibold">Broker Connection</h2>
          <div className="space-y-2">
            <p className="text-gray-600">
              Connect your Robinhood account via SnapTrade (read-only)
            </p>
            <button className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
              Connect Broker
            </button>
          </div>
        </section>

        <section className="bg-white rounded-lg shadow p-6 space-y-4">
          <h2 className="text-xl font-semibold">Quantum Optimizer</h2>
          <div className="flex items-center justify-between">
            <div>
              <p className="font-medium">Enable Quantum Mode</p>
              <p className="text-sm text-gray-600">
                Show mean-variance-skew portfolio comparison (simulator only)
              </p>
            </div>
            <label className="relative inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={settings?.quantum_mode || false}
                onChange={(e) => updateSettings.mutate({ quantum_mode: e.target.checked })}
                className="sr-only peer"
              />
              <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
            </label>
          </div>
        </section>

        <section className="bg-white rounded-lg shadow p-6 space-y-4">
          <h2 className="text-xl font-semibold">LLM Budget</h2>
          <div className="space-y-2">
            <label className="block text-sm font-medium">
              Monthly Budget (cents)
            </label>
            <input
              type="number"
              value={settings?.llm_budget_cents || 1000}
              onChange={(e) =>
                updateSettings.mutate({ llm_budget_cents: parseInt(e.target.value) })
              }
              className="w-full px-3 py-2 border rounded-lg"
              min={0}
              step={100}
            />
            <p className="text-sm text-gray-600">
              Current: ${((settings?.llm_budget_cents || 1000) / 100).toFixed(2)} / month
            </p>
          </div>
        </section>
      </div>
    </div>
  );
}
--- path: apps/web/components/PositionsTable.tsx
typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';
import { formatCurrency, formatPercent } from '@/lib/formatters';

export function PositionsTable() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const { data: positions, isLoading } = useQuery({
    queryKey: ['positions'],
    queryFn: async () => {
      const { data } = await supabase
        .from('positions')
        .select('*')
        .order('symbol');
      return data;
    },
    refetchInterval: 30000, // Refresh every 30s
  });

  if (isLoading) {
    return <div className="bg-white rounded-lg shadow p-6">Loading positions...</div>;
  }

  return (
    <div className="bg-white rounded-lg shadow overflow-hidden">
      <div className="px-6 py-4 border-b">
        <h2 className="text-xl font-semibold">Positions</h2>
      </div>
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className="bg-gray-50 border-b">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Symbol
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Qty
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Avg Price
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Delta
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Theta
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                Vega
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
                IVR
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {positions?.map((position) => (
              <tr key={position.id} className="hover:bg-gray-50">
                <td className="px-6 py-4 whitespace-nowrap font-medium">
                  {position.symbol}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">{position.qty}</td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {formatCurrency(position.avg_price)}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {position.greek_delta?.toFixed(2)}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {position.greek_theta?.toFixed(2)}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {position.greek_vega?.toFixed(2)}
                </td>
                <td className="px-6 py-4 whitespace-nowrap">
                  {formatPercent(position.iv_rank)}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}
--- path: apps/web/components/RiskBar.tsx
typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';

export function RiskBar() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const { data: positions } = useQuery({
    queryKey: ['positions'],
    queryFn: async () => {
      const { data } = await supabase.from('positions').select('*');
      return data;
    },
  });

  const totalDelta = positions?.reduce((sum, p) => sum + (p.greek_delta || 0), 0) || 0;
  const maxDelta = 100; // Example max portfolio delta
  const deltaPercent = Math.min(Math.abs(totalDelta) / maxDelta * 100, 100);

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">Portfolio Risk</h3>
      <div className="space-y-4">
        <div>
          <div className="flex justify-between mb-2">
            <span className="text-sm font-medium">Portfolio Delta</span>
            <span className="text-sm font-medium">{totalDelta.toFixed(2)}</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div
              className={`h-2 rounded-full ${
                deltaPercent > 80 ? 'bg-red-500' : deltaPercent > 50 ? 'bg-yellow-500' : 'bg-green-500'
              }`}
              style={{ width: `${deltaPercent}%` }}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
--- path: apps/web/components/GuardrailList.tsx
typescript
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';

export function GuardrailList() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
  const queryClient = useQueryClient();

  const { data: guardrails } = useQuery({
    queryKey: ['guardrails'],
    queryFn: async () => {
      const { data } = await supabase
        .from('rules_guardrails')
        .select('*')
        .order('added_ts', { ascending: false });
      return data;
    },
  });

  const toggleGuardrail = useMutation({
    mutationFn: async ({ id, enabled }: { id: string; enabled: boolean }) => {
      const { data } = await supabase
        .from('rules_guardrails')
        .update({ enabled })
        .eq('id', id)
        .select()
        .single();
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['guardrails'] });
    },
  });

  const priorityColors = {
    high: 'bg-red-100 text-red-800',
    medium: 'bg-yellow-100 text-yellow-800',
    low: 'bg-green-100 text-green-800',
  };

  return (
    <div className="bg-white rounded-lg shadow">
      {guardrails?.map((rule) => (
        <div key={rule.id} className="p-6 border-b last:border-b-0 flex items-start gap-4">
          <input
            type="checkbox"
            checked={rule.enabled}
            onChange={(e) =>
              toggleGuardrail.mutate({ id: rule.id, enabled: e.target.checked })
            }
            className="mt-1"
          />
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-2">
              <span
                className={`px-2 py-1 text-xs font-medium rounded ${
                  priorityColors[rule.priority as keyof typeof priorityColors]
                }`}
              >
                {rule.priority}
              </span>
              <span className="text-sm text-gray-500">
                {new Date(rule.added_ts).toLocaleDateString()}
              </span>
            </div>
            <p className="font-medium mb-1">{rule.rule_key}</p>
            <p className="text-gray-700">{rule.rule_text}</p>
          </div>
        </div>
      ))}
    </div>
  );
}
--- path: apps/web/components/CandidateForm.tsx
typescript
'use client';

import { useState } from 'react';
import { useMutation } from '@tanstack/react-query';

export function CandidateForm() {
  const [symbol, setSymbol] = useState('');
  const [strategy, setStrategy] = useState('');
  const [expiry, setExpiry] = useState('');
  const [strikes, setStrikes] = useState('');
  const [result, setResult] = useState<any>(null);

  const validateCandidate = useMutation({
    mutationFn: async (candidate: any) => {
      // Call backend RPC to validate via LLM
      const response = await fetch('/api/validate-candidate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(candidate),
      });
      return response.json();
    },
    onSuccess: (data) => {
      setResult(data);
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    validateCandidate.mutate({
      symbol,
      strategy,
      expiry,
      strikes: strikes.split(',').map((s) => parseFloat(s.trim())),
    });
  };

  return (
    <div className="space-y-6">
      <form onSubmit={handleSubmit} className="bg-white rounded-lg shadow p-6 space-y-4">
        <div>
          <label className="block text-sm font-medium mb-2">Symbol</label>
          <input
            type="text"
            value={symbol}
            onChange={(e) => setSymbol(e.target.value.toUpperCase())}
            className="w-full px-3 py-2 border rounded-lg"
            placeholder="SPY"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Strategy</label>
          <select
            value={strategy}
            onChange={(e) => setStrategy(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            required
          >
            <option value="">Select strategy</option>
            <option value="credit_put_spread">Credit Put Spread</option>
            <option value="iron_condor">Iron Condor</option>
            <option value="covered_call">Covered Call</option>
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Expiry (YYYY-MM-DD)</label>
          <input
            type="date"
            value={expiry}
            onChange={(e) => setExpiry(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">
            Strikes (comma-separated)
          </label>
          <input
            type="text"
            value={strikes}
            onChange={(e) => setStrikes(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            placeholder="540, 545"
            required
          />
        </div>

        <button
          type="submit"
          disabled={validateCandidate.isPending}
          className="w-full py-2 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
        >
          {validateCandidate.isPending ? 'Validating...' : 'Validate Trade'}
        </button>
      </form>

      {result && (
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-lg font-semibold mb-4">Validation Result</h3>
          <div className="space-y-4">
            <div>
              <span className="font-medium">Decision: </span>
              <span
                className={`px-2 py-1 rounded text-sm ${
                  result.decision === 'accept'
                    ? 'bg-green-100 text-green-800'
                    : result.decision === 'revise'
                    ? 'bg-yellow-100 text-yellow-800'
                    : 'bg-red-100 text-red-800'
                }`}
              >
                {result.decision}
              </span>
            </div>
            {result.reasons && (
              <div>
                <p className="font-medium mb-2">Reasons:</p>
                <ul className="list-disc list-inside space-y-1">
                  {result.reasons.map((reason: string, i: number) => (
                    <li key={i} className="text-gray-700">
                      {reason}
                    </li>
                  ))}
                </ul>
              </div>
            )}
            {result.alternative && (
              <div>
                <p className="font-medium mb-2">Suggested Alternative:</p>
                <pre className="bg-gray-50 p-4 rounded text-sm overflow-x-auto">
                  {JSON.stringify(result.alternative, null, 2)}
                </pre>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
--- path: apps/web/components/QuantumCompare.tsx
typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';

export function QuantumCompare() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const { data: settings } = useQuery({
    queryKey: ['settings'],
    queryFn: async () => {
      const { data: user } = await supabase.auth.getUser();
      const { data } = await supabase
        .from('settings')
        .select('*')
        .eq('user_id', user.data.user?.id)
        .single();
      return data;
    },
  });

  const { data: optimization } = useQuery({
    queryKey: ['quantum-optimization'],
    queryFn: async () => {
      // Mock data - in production would call quantum optimizer
      return {
        mv: { sharpe: 1.45, maxDD: -12.3, weights: { SPY: 0.25, QQQ: 0.25, IWM: 0.25, DIA: 0.25 } },
        mvs: { sharpe: 1.52, maxDD: -11.8, weights: { SPY: 0.30, QQQ: 0.20, IWM: 0.25, DIA: 0.25 } },
      };
    },
    enabled: settings?.quantum_mode === true,
  });

  if (!settings?.quantum_mode) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h3 className="text-lg font-semibold mb-2">Quantum Optimizer</h3>
        <p className="text-gray-600 text-sm">
          Enable quantum mode in settings to see portfolio optimization comparisons.
        </p>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">Quantum Portfolio Comparison</h3>
      <div className="space-y-4">
        <div className="bg-blue-50 p-4 rounded">
          <p className="text-sm font-medium text-blue-900 mb-2">Mean-Variance (MV)</p>
          <div className="space-y-1 text-sm">
            <div>Sharpe: {optimization?.mv.sharpe.toFixed(2)}</div>
            <div>Max DD: {optimization?.mv.maxDD.toFixed(1)}%</div>
          </div>
        </div>

        <div className="bg-purple-50 p-4 rounded">
          <p className="text-sm font-medium text-purple-900 mb-2">Mean-Variance-Skew (MVS)</p>
          <div className="space-y-1 text-sm">
            <div>Sharpe: {optimization?.mvs.sharpe.toFixed(2)}</div>
            <div>Max DD: {optimization?.mvs.maxDD.toFixed(1)}%</div>
          </div>
        </div>

        <p className="text-xs text-gray-500">
          ⚠️ Simulator mode only. No auto-apply.
        </p>
      </div>
    </div>
  );
}
--- path: apps/web/components/AlertBell.tsx
typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';

export function AlertBell() {
  const supabase = createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );

  const { data: alerts } = useQuery({
    queryKey: ['alerts'],
    queryFn: async () => {
      const { data } = await supabase
        .from('alerts')
        .select('*')
        .eq('status', 'unread')
        .order('created_at', { ascending: false });
      return data;
    },
    refetchInterval: 30000,
  });

  const unreadCount = alerts?.length || 0;

  return (
    <div className="relative">
      <button className="p-2 rounded-full hover:bg-gray-100">
        <svg
          className="w-6 h-6"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
          />
        </svg>
      </button>
      {unreadCount > 0 && (
        <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
          {unreadCount}
        </span>
      )}
    </div>
  );
}
--- path: apps/web/components/ui/button.tsx
typescript
import * as React from 'react';

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, ...props }, ref) => {
    return (
      <button
        className={`px-4 py-2 rounded-lg font-medium transition-colors ${className}`}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';

export { Button };
--- path: apps/web/components/ui/card.tsx
typescript
import * as React from 'react';

export function Card({ children, className = '' }: { children: React.ReactNode; className?: string }) {
  return <div className={`bg-white rounded-lg shadow ${className}`}>{children}</div>;
}

export function CardHeader({ children }: { children: React.ReactNode }) {
  return <div className="px-6 py-4 border-b">{children}</div>;
}

export function CardContent({ children }: { children: React.ReactNode }) {
  return <div className="p-6">{children}</div>;
}
--- path: apps/web/components/ui/input.tsx
typescript
import * as React from 'react';

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={`w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 ${className}`}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';

export { Input };
--- path: apps/web/components/ui/badge.tsx
typescript
import * as React from 'react';

export function Badge({
  children,
  variant = 'default',
}: {
  children: React.ReactNode;
  variant?: 'default' | 'success' | 'warning' | 'danger';
}) {
  const variants = {
    default: 'bg-gray-100 text-gray-800',
    success: 'bg-green-100 text-green-800',
    warning: 'bg-yellow-100 text-yellow-800',
    danger: 'bg-red-100 text-red-800',
  };

  return (
    <span className={`px-2 py-1 text-xs font-medium rounded ${variants[variant]}`}>
      {children}
    </span>
  );
}
--- path: apps/web/lib/client/supabase.ts
typescript
import { createBrowserClient } from '@supabase/ssr';
import { env } from '@/env';

export function createClient() {
  return createBrowserClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
}
--- path: apps/web/lib/client/query-provider.tsx
typescript
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';

export function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
--- path: apps/web/lib/client/queries.ts
typescript
import { createClient } from './supabase';

export async function getPositions() {
  const supabase = createClient();
  const { data, error } = await supabase.from('positions').select('*').order('symbol');
  if (error) throw error;
  return data;
}

export async function getTrades() {
  const supabase = createClient();
  const { data, error } = await supabase
    .from('trades')
    .select('*')
    .order('open_ts', { ascending: false });
  if (error) throw error;
  return data;
}

export async function getGuardrails() {
  const supabase = createClient();
  const { data, error } = await supabase
    .from('rules_guardrails')
    .select('*')
    .eq('enabled', true)
    .order('priority', { ascending: false });
  if (error) throw error;
  return data;
}
--- path: apps/web/lib/formatters.ts
typescript
export function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(value);
}

export function formatPercent(value: number): string {
  return `${(value * 100).toFixed(2)}%`;
}

export function formatDate(date: string): string {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
}

export function formatNumber(value: number, decimals: number = 2): string {
  return value.toFixed(decimals);
}
--- path: apps/worker/package.json
json
{
  "name": "@app/worker",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy"
  },
  "dependencies": {
    "@core/types": "workspace:*",
    "@data/features": "workspace:*",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20231218.0",
    "wrangler": "^3.22.1"
  }
}
--- path: apps/worker/wrangler.toml
toml
name = "options-trading-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[env.production]
name = "options-trading-worker"

# Cron triggers
[triggers]
crons = ["*/30 * * * *"]

# Environment variables (set via CLI or dashboard)
[vars]
SUPABASE_URL = ""
SUPABASE_SERVICE_KEY = ""
ANTHROPIC_API_KEY = ""
--- path: apps/worker/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "types": ["@cloudflare/workers-types"]
  },
  "include": ["src/**/*"]
}
--- path: apps/worker/src/index.ts
typescript
import { handleCron } from './cron';
import { handleWebhook } from './webhooks';

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname.startsWith('/webhook')) {
      return handleWebhook(request, env);
    }

    return new Response('Options Trading Worker', { status: 200 });
  },

  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {
    ctx.waitUntil(handleCron(env));
  },
};

export interface Env {
  SUPABASE_URL: string;
  SUPABASE_SERVICE_KEY: string;
  ANTHROPIC_API_KEY: string;
  MARKETDATA_API_KEY: string;
}
--- path: apps/worker/src/cron.ts
typescript
import type { Env } from './index';

export async function handleCron(env: Env): Promise<void> {
  console.log('Cron job started at', new Date().toISOString());

  try {
    // 1. Fetch watchlist from Supabase
    const watchlist = await fetchWatchlist(env);

    // 2. Refresh market features for each symbol
    for (const symbol of watchlist) {
      await refreshFeatures(symbol, env);
    }

    // 3. Run gating logic and enqueue scout jobs
    await runGatingAndScout(env);

    console.log('Cron job completed successfully');
  } catch (error) {
    console.error('Cron job failed:', error);
    throw error;
  }
}

async function fetchWatchlist(env: Env): Promise<string[]> {
  // Fetch active symbols from settings or default universe
  return ['SPY', 'QQQ', 'IWM', 'AAPL', 'MSFT'];
}

async function refreshFeatures(symbol: string, env: Env): Promise<void> {
  // Call market data API to refresh features
  // Store in Supabase or Durable Object ring buffer
  console.log(`Refreshing features for ${symbol}`);
}

async function runGatingAndScout(env: Env): Promise<void> {
  // Check gating criteria
  // If eligible, call LLM Trade Scout
  // Debounce per symbol (3 min minimum)
  // Respect monthly LLM budget
  console.log('Running gating and scout jobs');
}
--- path: apps/worker/src/webhooks.ts
typescript
import type { Env } from './index';

export async function handleWebhook(request: Request, env: Env): Promise<Response> {
  const url = new URL(request.url);
  const path = url.pathname;

  if (path === '/webhook/broker') {
    return handleBrokerWebhook(request, env);
  }

  return new Response('Webhook not found', { status: 404 });
}

async function handleBrokerWebhook(request: Request, env: Env): Promise<Response> {
  try {
    const payload = await request.json();

    // Verify webhook signature
    // Update positions in Supabase
    console.log('Broker webhook received:', payload);

    return new Response('OK', { status: 200 });
  } catch (error) {
    console.error('Webhook error:', error);
    return new Response('Internal error', { status: 500 });
  }
}
--- path: packages/core/package.json
json
{
  "name": "@core/types",
  "version": "1.0.0",
  "private": true,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "build": "tsc --noEmit",
    "test": "vitest"
  },
  "dependencies": {
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "typescript": "^5.3.3",
    "vitest": "^1.1.0"
  }
}
--- path: packages/core/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
--- path: packages/core/src/index.ts
typescript
export * from './types';
export * from './schemas';
export * from './gate';
--- path: packages/core/src/types.ts
typescript
export interface Position {
  id: string;
  user_id: string;
  symbol: string;
  qty: number;
  avg_price: number;
  greek_delta: number | null;
  greek_theta: number | null;
  greek_vega: number | null;
  iv_rank: number | null;
  updated_at: string;
}

export interface Trade {
  id: string;
  user_id: string;
  symbol: string;
  strategy_id: string;
  open_ts: string;
  close_ts: string | null;
  pnl_pct: number | null;
  legs_json: any;
  thesis_json: any;
  market_snapshot_json: any;
}

export interface Guardrail {
  id: string;
  user_id: string;
  rule_key: string;
  rule_text: string;
  priority: 'low' | 'medium' | 'high';
  enabled: boolean;
  added_ts: string;
}

export interface LossReview {
  id: string;
  trade_id: string;
  root_cause: string;
  evidence_json: any;
  recommended_rule_json: any;
  confidence: number;
  created_at: string;
}

export interface MarketFeatures {
  symbol: string;
  spot: number;
  spread_bps: number;
  iv_rank: number;
  iv_percentile: number;
  rv_1m: number;
  rv_5m: number;
  rv_15m: number;
  vix_level: number;
  spx_trend: number;
  smile_slope: number;
  term_slope: number;
  days_to_earnings: number;
  oi_median: number;
  spread_bps_median: number;
  timestamp: string;
}

export interface GatingResult {
  eligible: boolean;
  reasons: string[];
  signal_strength: number; // 0..1
}
--- path: packages/core/src/schemas.ts
typescript
import { z } from 'zod';

export const CandidateTradeSchema = z.object({
  symbol: z.string().min(1).max(10),
  strategy_id: z.string(),
  expiry: z.string().datetime(),
  strikes: z.array(z.number()),
  delta_target: z.number().optional(),
  max_risk: z.number().optional(),
  thesis: z.string(),
});

export const LossReviewOutputSchema = z.object({
  root_cause: z.enum([
    'timing',
    'thesis_invalid',
    'execution',
    'sizing',
    'vol_crush',
    'liquidity',
    'insufficient_evidence',
  ]),
  evidence: z.array(z.string()),
  recommended_guardrail: z.object({
    idempotent_key: z.string(),
    rule: z.string(),
    explanation: z.string(),
    priority: z.enum(['low', 'medium', 'high']),
    expected_effects: z.object({
      win_rate_delta_bp: z.number(),
      annual_return_delta_bp: z.number(),
      trade_frequency_delta_bp: z.number(),
    }),
    test_plan: z.object({
      ab_design: z.string(),
      acceptance_criteria: z.array(z.string()),
      rollback_conditions: z.array(z.string()),
    }),
  }),
  quantum_reopt_recommendation: z.object({
    should_run: z.boolean(),
    objective: z.string(),
    constraints: z.array(z.string()),
    reason: z.string(),
  }),
  confidence: z.number().min(0).max(1),
});

export const TradeScoutOutputSchema = z.object({
  candidates: z.array(
    z.object({
      symbol: z.string(),
      strategy_id: z.string(),
      expiry: z.string(),
      strikes: z.array(z.number()),
      expected_credit: z.number(),
      max_risk: z.number(),
      reasoning: z.string(),
      signal_strength: z.number(),
    })
  ).max(3),
});

export const CandidateCheckOutputSchema = z.object({
  decision: z.enum(['accept', 'revise', 'reject']),
  reasons: z.array(z.string()),
  alternative: z.object({
    expiry: z.string().optional(),
    strikes: z.array(z.number()).optional(),
    reasoning: z.string().optional(),
  }).optional(),
});

export type CandidateTrade = z.infer<typeof CandidateTradeSchema>;
export type LossReviewOutput = z.infer<typeof LossReviewOutputSchema>;
export type TradeScoutOutput = z.infer<typeof TradeScoutOutputSchema>;
export type CandidateCheckOutput = z.infer<typeof CandidateCheckOutputSchema>;
--- path: packages/core/src/gate.ts
typescript
import type { MarketFeatures, GatingResult } from './types';

export interface StrategyProfile {
  universe: string[];
  eligibility: {
    min_price: number;
    iv_rank: { min: number; max: number };
    earnings_window: { min_days_before: number; hold_through_earnings: boolean };
    liquidity: { min_oi: number; max_spread_bps: number };
    delta_range: { short_leg: [number, number]; long_leg: [number, number] };
    dte: { min: number; max: number };
  };
  sizing: {
    per_trade_risk_pct: number;
    max_ticker_risk_pct: number;
    max_portfolio_delta: number;
  };
  exits: {
    profit_target_pct: number;
    stop_loss_pct: number;
    time_exit_days: number;
    vol_exit_rule: string;
  };
  notes: string;
}

export function gate(features: MarketFeatures, profile: StrategyProfile): GatingResult {
  const reasons: string[] = [];
  let eligible = true;

  // Check universe
  if (!profile.universe.includes(features.symbol)) {
    eligible = false;
    reasons.push('Symbol not in strategy universe');
  }

  // Check IV rank
  if (
    features.iv_rank < profile.eligibility.iv_rank.min ||
    features.iv_rank > profile.eligibility.iv_rank.max
  ) {
    eligible = false;
    reasons.push(
      `IV rank ${(features.iv_rank * 100).toFixed(0)}% outside range [${profile.eligibility.iv_rank.min * 100}-${profile.eligibility.iv_rank.max * 100}%]`
    );
  }

  // Check earnings window
  if (
    !profile.eligibility.earnings_window.hold_through_earnings &&
    features.days_to_earnings < profile.eligibility.earnings_window.min_days_before
  ) {
    eligible = false;
    reasons.push(`Too close to earnings (${features.days_to_earnings} days)`);
  }

  // Check liquidity
  if (features.oi_median < profile.eligibility.liquidity.min_oi) {
    eligible = false;
    reasons.push(`Insufficient open interest (${features.oi_median})`);
  }

  if (features.spread_bps > profile.eligibility.liquidity.max_spread_bps) {
    eligible = false;
    reasons.push(`Spread too wide (${features.spread_bps} bps)`);
  }

  // Calculate signal strength (weighted score 0..1)
  let signal_strength = 0;

  if (eligible) {
    // IVR position (30% weight)
    const ivr_score = Math.min(features.iv_rank / 0.8, 1.0);
    signal_strength += ivr_score * 0.3;

    // Liquidity (25% weight)
    const liquidity_score = Math.min(features.oi_median / 5000, 1.0);
    signal_strength += liquidity_score * 0.25;

    // Smile slope (20% weight)
    const smile_score = Math.abs(features.smile_slope) > 0.1 ? 0.8 : 0.3;
    signal_strength += smile_score * 0.2;

    // Term structure (15% weight)
    const term_score = features.term_slope > 0 ? 0.9 : 0.4;
    signal_strength += term_score * 0.15;

    // Regime fit (10% weight)
    const regime_score = features.vix_level < 25 ? 0.8 : 0.5;
    signal_strength += regime_score * 0.1;

    signal_strength = Math.max(0, Math.min(1, signal_strength));
  }

  return {
    eligible,
    reasons,
    signal_strength,
  };
}
--- path: packages/server/package.json
json
{
  "name": "@server/rpc",
  "version": "1.0.0",
  "private": true,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "build": "tsc --noEmit"
  },
  "dependencies": {
    "@core/types": "workspace:*",
    "@supabase/supabase-js": "^2.39.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "typescript": "^5.3.3"
  }
}
--- path: packages/server/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
--- path: packages/server/src/index.ts
typescript
export * from './rpc';
export * from './auth';
--- path: packages/server/src/rpc.ts
typescript
import type { MarketFeatures } from '@core/types';

export interface MarketSnapshot {
  symbol: string;
  features: MarketFeatures;
  history_60m: MarketFeatures[];
  last_update: string;
}

export interface OptionLadder {
  symbol: string;
  expiry: string;
  strikes: Array<{
    strike: number;
    delta: number;
    bid: number;
    ask: number;
    mid: number;
    iv: number;
    oi: number;
    volume: number;
  }>;
}

export interface PositionSizeResult {
  contracts: number;
  max_risk: number;
  position_size_pct: number;
  rationale: string;
}

export interface RiskCheckResult {
  pass: boolean;
  reasons: string[];
  exposures: {
    current_delta: number;
    new_delta: number;
    total_delta: number;
    max_delta: number;
    ticker_risk_pct: number;
    max_ticker_risk_pct: number;
  };
}

// RPC function signatures
export async function getMarketSnapshot(
  symbol: string,
  supabaseUrl: string,
  serviceKey: string
): Promise<MarketSnapshot> {
  // Fetch from feature store
  throw new Error('Not implemented');
}

export async function getOptionLadder(
  symbol: string,
  expiry: string,
  aroundDeltas: number[],
  marketDataKey: string
): Promise<OptionLadder> {
  // Fetch from market data API
  throw new Error('Not implemented');
}

export async function calcPositionSize(
  profileId: string,
  accountContext: any,
  supabaseUrl: string,
  serviceKey: string
): Promise<PositionSizeResult> {
  // Calculate based on profile sizing rules
  throw new Error('Not implemented');
}

export async function riskCheck(
  candidateTrade: any,
  portfolioExposures: any,
  supabaseUrl: string,
  serviceKey: string
): Promise<RiskCheckResult> {
  // Check against risk limits
  throw new Error('Not implemented');
}

export async function placeAlert(
  userId: string,
  candidateTrade: any,
  supabaseUrl: string,
  serviceKey: string
): Promise<{ id: string }> {
  // Insert alert into database
  throw new Error('Not implemented');
}
--- path: packages/server/src/auth.ts
typescript
import { createClient } from '@supabase/supabase-js';

export function createServiceClient(supabaseUrl: string, serviceKey: string) {
  return createClient(supabaseUrl, serviceKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
}

export async function validateServiceRole(supabaseUrl: string, serviceKey: string): Promise<boolean> {
  const client = createServiceClient(supabaseUrl, serviceKey);
  try {
    const { error } = await client.from('users').select('count').limit(1).single();
    return !error;
  } catch {
    return false;
  }
}
--- path: packages/data/package.json
json
{
  "name": "@data/features",
  "version": "1.0.0",
  "private": true,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "build": "tsc --noEmit"
  },
  "dependencies": {
    "@core/types": "workspace:*",
    "ws": "^8.16.0"
  },
  "devDependencies": {
    "@types/ws": "^8.5.10",
    "typescript": "^5.3.3"
  }
}
--- path: packages/data/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
--- path: packages/data/src/index.ts
typescript
export * from './websocket';
export * from './snapshot';
export * from './features';
--- path: packages/data/src/websocket.ts
typescript
import WebSocket from 'ws';
import type { MarketFeatures } from '@core/types';

export class MarketDataWebSocket {
  private ws: WebSocket | null = null;
  private reconnectTimeout: NodeJS.Timeout | null = null;

  constructor(
    private apiKey: string,
    private symbols: string[],
    private onFeatures: (features: MarketFeatures) => void
  ) {}

  connect(): void {
    // Example: Polygon.io or Massive-style websocket
    const wsUrl = `wss://socket.polygon.io/options`;

    this.ws = new WebSocket(wsUrl);

    this.ws.on('open', () => {
      console.log('WebSocket connected');
      this.authenticate();
      this.subscribe();
    });

    this.ws.on('message', (data) => {
      this.handleMessage(data.toString());
    });

    this.ws.on('close', () => {
      console.log('WebSocket closed, reconnecting...');
      this.scheduleReconnect();
    });

    this.ws.on('error', (error) => {
      console.error('WebSocket error:', error);
    });
  }

  private authenticate(): void {
    this.send({ action: 'auth', params: this.apiKey });
  }

  private subscribe(): void {
    this.symbols.forEach((symbol) => {
      this.send({ action: 'subscribe', params: `T.${symbol}` });
    });
  }

  private handleMessage(data: string): void {
    try {
      const msg = JSON.parse(data);
      // Transform to MarketFeatures and call onFeatures
      // This is a stub - actual implementation depends on data provider
    } catch (error) {
      console.error('Failed to parse message:', error);
    }
  }

  private send(data: any): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }

  private scheduleReconnect(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
    this.reconnectTimeout = setTimeout(() => {
      this.connect();
    }, 5000);
  }

  disconnect(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
    this.ws?.close();
  }
}
--- path: packages/data/src/snapshot.ts
typescript
import type { MarketFeatures } from '@core/types';

export async function fetchSnapshot(
  symbol: string,
  expiry: string,
  apiKey: string
): Promise<any> {
  // Fetch full option chain snapshot
  // Example: Polygon.io /v3/snapshot/options/{symbol}
  const url = `https://api.polygon.io/v3/snapshot/options/${symbol}?expiry=${expiry}&apiKey=${apiKey}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch snapshot: ${response.statusText}`);
  }
  return response.json();
}

export function calculateFeatures(snapshot: any): Partial<MarketFeatures> {
  // Extract and calculate features from snapshot data
  // This is a stub - actual implementation depends on data format
  return {
    symbol: snapshot.symbol,
    spot: snapshot.underlying_price,
    spread_bps: calculateSpreadBps(snapshot),
    iv_rank: calculateIVRank(snapshot),
    oi_median: calculateOIMedian(snapshot),
    timestamp: new Date().toISOString(),
  };
}

function calculateSpreadBps(snapshot: any): number {
  // Calculate average bid-ask spread in basis points
  return 0;
}

function calculateIVRank(snapshot: any): number {
  // Calculate IV rank (current IV position in 52-week range)
  return 0;
}

function calculateOIMedian(snapshot: any): number {
  // Calculate median open interest across strikes
  return 0;
}
--- path: packages/data/src/features.ts
typescript
import type { MarketFeatures } from '@core/types';

export class FeatureStore {
  private buffer: Map<string, MarketFeatures[]> = new Map();
  private readonly maxAge = 90 * 60 * 1000; // 90 minutes

  add(features: MarketFeatures): void {
    const symbol = features.symbol;
    if (!this.buffer.has(symbol)) {
      this.buffer.set(symbol, []);
    }

    const symbolBuffer = this.buffer.get(symbol)!;
    symbolBuffer.push(features);

    // Trim old data
    const cutoff = Date.now() - this.maxAge;
    const filtered = symbolBuffer.filter(
      (f) => new Date(f.timestamp).getTime() > cutoff
    );
    this.buffer.set(symbol, filtered);
  }

  getRecent(symbol: string, minutes: number = 60): MarketFeatures[] {
    const symbolBuffer = this.buffer.get(symbol) || [];
    const cutoff = Date.now() - minutes * 60 * 1000;
    return symbolBuffer.filter(
      (f) => new Date(f.timestamp).getTime() > cutoff
    );
  }

  getLatest(symbol: string): MarketFeatures | null {
    const symbolBuffer = this.buffer.get(symbol) || [];
    return symbolBuffer[symbolBuffer.length - 1] || null;
  }

  calculateAggregates(symbol: string): {
    avg_iv_rank: number;
    avg_spread_bps: number;
    volatility: number;
  } | null {
    const recent = this.getRecent(symbol, 60);
    if (recent.length === 0) return null;

    const avg_iv_rank = recent.reduce((sum, f) => sum + f.iv_rank, 0) / recent.length;
    const avg_spread_bps = recent.reduce((sum, f) => sum + f.spread_bps, 0) / recent.length;

    // Calculate price volatility
    const prices = recent.map((f) => f.spot);
    const mean = prices.reduce((a, b) => a + b) / prices.length;
    const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;
    const volatility = Math.sqrt(variance);

    return { avg_iv_rank, avg_spread_bps, volatility };
  }
}
--- path: packages/ai/package.json
json
{
  "name": "@ai/claude",
  "version": "1.0.0",
  "private": true,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "build": "tsc --noEmit"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.0",
    "@core/types": "workspace:*",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "typescript": "^5.3.3"
  }
}
--- path: packages/ai/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
--- path: packages/ai/src/index.ts
typescript
export * from './client';
export * from './prompts';
export * from './tools';
--- path: packages/ai/src/client.ts
typescript
import Anthropic from '@anthropic-ai/sdk';

export class ClaudeClient {
  private client: Anthropic;

  constructor(apiKey: string) {
    this.client = new Anthropic({ apiKey });
  }

  async complete(
    prompt: string,
    systemPrompt: string,
    tools?: any[],
    maxTokens: number = 4096
  ): Promise<any> {
    const response = await this.client.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: maxTokens,
      system: [
        {
          type: 'text',
          text: systemPrompt,
          cache_control: { type: 'ephemeral' },
        },
      ],
      messages: [
        {
          role: 'user',
          content: prompt,
        },
      ],
      tools: tools || [],
    });

    return response;
  }

  async completeWithToolUse(
    prompt: string,
    systemPrompt: string,
    tools: any[],
    toolExecutor: (name: string, input: any) => Promise<any>
  ): Promise<string> {
    let messages: any[] = [{ role: 'user', content: prompt }];

    while (true) {
      const response = await this.client.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 4096,
        system: [
          {
            type: 'text',
            text: systemPrompt,
            cache_control: { type: 'ephemeral' },
          },
        ],
        messages,
        tools,
      });

      if (response.stop_reason === 'end_turn') {
        const textContent = response.content.find((c: any) => c.type === 'text');
        return textContent?.text || '';
      }

      if (response.stop_reason === 'tool_use') {
        const toolUse = response.content.find((c: any) => c.type === 'tool_use');
        if (toolUse) {
          const result = await toolExecutor(toolUse.name, toolUse.input);
          messages.push({
            role: 'assistant',
            content: response.content,
          });
          messages.push({
            role: 'user',
            content: [
              {
                type: 'tool_result',
                tool_use_id: toolUse.id,
                content: JSON.stringify(result),
              },
            ],
          });
          continue;
        }
      }

      throw new Error(`Unexpected stop reason: ${response.stop_reason}`);
    }
  }
}
--- path: packages/ai/src/prompts.ts
typescript
export const TRADE_SCOUT_SYSTEM_PROMPT = `You are an expert options trader specializing in high-probability, defined-risk strategies. Your role is to scout and propose trade candidates that strictly adhere to strategy profiles and pass all gating criteria.

CRITICAL RULES:
- All candidates MUST pass gating checks (IVR, liquidity, earnings, DTE)
- Propose maximum 3 candidates per call
- Output STRICT JSON matching TradeScoutOutputSchema
- Never propose trades through earnings if strategy prohibits it
- Always check current guardrails before proposing

For each candidate, provide:
- Symbol and strategy_id
- Specific strikes and expiry
- Expected credit and max risk
- Clear reasoning based on market features
- Signal strength (0-1) based on conviction`;

export const CANDIDATE_CHECK_SYSTEM_PROMPT = `You are an expert options risk analyst. Your role is to validate user-proposed trades against strategy profiles and current market conditions.

CRITICAL RULES:
- Check ALL eligibility criteria (IVR, earnings, liquidity, DTE, delta availability)
- Accept only if all criteria pass
- If minor issues, propose revised strikes/expiry (revise decision)
- If major violations, reject with clear reasons
- Output STRICT JSON matching CandidateCheckOutputSchema
- Never accept trades that violate active guardrails

Decision logic:
- accept: All criteria met, trade is executable
- revise: Good thesis but execution needs adjustment
- reject: Violates hard constraints or guardrails`;

export const LOSS_REVIEW_SYSTEM_PROMPT = `You are an expert trading psychologist and risk analyst. Your role is to diagnose losing trades and propose atomic, testable guardrails to prevent similar losses.

CRITICAL RULES:
- Identify ONE root cause (timing, thesis_invalid, execution, sizing, vol_crush, liquidity, insufficient_evidence)
- Provide specific evidence from trade data
- Propose ONE atomic guardrail rule (if-then format)
- Estimate impact on win rate, returns, and frequency
- Design A/B test plan with acceptance criteria
- Output STRICT JSON matching LossReviewOutputSchema
- Confidence must reflect evidence quality

Guardrail rules must be:
- Idempotent (same key if rule already exists)
- Specific and testable
- Forward-looking (prevent future occurrences)
- Balanced (don't over-constrain)

If evidence is insufficient, set root_cause to "insufficient_evidence" and confidence < 0.5`;

export function buildTradeScoutPrompt(
  watchlist: string[],
  marketFeatures: any,
  activeGuardrails: any[],
  strategyProfile: any
): string {
  return `Analyze the current market and propose up to 3 high-quality trade candidates.

WATCHLIST: ${watchlist.join(', ')}

MARKET FEATURES:
${JSON.stringify(marketFeatures, null, 2)}

ACTIVE GUARDRAILS:
${JSON.stringify(activeGuardrails, null, 2)}

STRATEGY PROFILE:
${JSON.stringify(strategyProfile, null, 2)}

Propose candidates that:
1. Pass all gating criteria
2. Have signal_strength >= 0.65
3. Respect active guardrails
4. Offer good risk/reward per strategy profile

Return JSON array of candidates (max 3).`;
}

export function buildCandidateCheckPrompt(
  candidate: any,
  marketSnapshot: any,
  strategyProfile: any,
  activeGuardrails: any[]
): string {
  return `Validate this trade candidate:

CANDIDATE:
${JSON.stringify(candidate, null, 2)}

CURRENT MARKET SNAPSHOT:
${JSON.stringify(marketSnapshot, null, 2)}

STRATEGY PROFILE:
${JSON.stringify(strategyProfile, null, 2)}

ACTIVE GUARDRAILS:
${JSON.stringify(activeGuardrails, null, 2)}

Check:
1. IVR in range
2. Liquidity sufficient (OI, spread)
3. Earnings window safe
4. DTE in range
5. Delta strikes available
6. No guardrail violations

Return decision (accept/revise/reject) with reasons and optional alternative.`;
}

export function buildLossReviewPrompt(
  trade: any,
  entrySnapshot: any,
  exitSnapshot: any
): string {
  return `Analyze this losing trade and propose a guardrail rule.

TRADE:
${JSON.stringify(trade, null, 2)}

ENTRY MARKET SNAPSHOT:
${JSON.stringify(entrySnapshot, null, 2)}

EXIT MARKET SNAPSHOT:
${JSON.stringify(exitSnapshot, null, 2)}

Diagnose:
1. What was the root cause of the loss?
2. What evidence supports this diagnosis?
3. What single rule would have prevented it?
4. How would this rule impact future performance?
5. How confident are you in this analysis?

Return JSON with root_cause, evidence, recommended_guardrail, quantum_reopt_recommendation, and confidence.`;
}
--- path: packages/ai/src/tools.ts
typescript
export const MARKET_SNAPSHOT_TOOL = {
  name: 'get_market_snapshot',
  description: 'Fetch current market features and 60-90 minute history for a symbol',
  input_schema: {
    type: 'object',
    properties: {
      symbol: {
        type: 'string',
        description: 'Stock or ETF symbol (e.g., SPY, AAPL)',
      },
    },
    required: ['symbol'],
  },
};

export const OPTION_LADDER_TOOL = {
  name: 'get_option_ladder',
  description: 'Fetch option chain ladder around target deltas for specific expiry',
  input_schema: {
    type: 'object',
    properties: {
      symbol: {
        type: 'string',
        description: 'Underlying symbol',
      },
      expiry: {
        type: 'string',
        description: 'Expiry date (YYYY-MM-DD)',
      },
      around_deltas: {
        type: 'array',
        items: { type: 'number' },
        description: 'Target delta levels (e.g., [0.15, 0.30, 0.50])',
      },
    },
    required: ['symbol', 'expiry'],
  },
};

export const RISK_CHECK_TOOL = {
  name: 'risk_check',
  description: 'Validate trade against portfolio risk limits and exposures',
  input_schema: {
    type: 'object',
    properties: {
      candidate_trade: {
        type: 'object',
        description: 'Trade candidate to check',
      },
    },
    required: ['candidate_trade'],
  },
};

export const ALL_TOOLS = [MARKET_SNAPSHOT_TOOL, OPTION_LADDER_TOOL, RISK_CHECK_TOOL];
--- path: packages/risk/package.json
json
{
  "name": "@risk/engine",
  "version": "1.0.0",
  "private": true,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "build": "tsc --noEmit",
    "test": "vitest"
  },
  "dependencies": {
    "@core/types": "workspace:*",
    "js-yaml": "^4.1.0"
  },
  "devDependencies": {
    "@types/js-yaml": "^4.0.9",
    "typescript": "^5.3.3",
    "vitest": "^1.1.0"
  }
}
--- path: packages/risk/tsconfig.json
json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
--- path: packages/risk/src/index.ts
typescript
export * from './engine';
export * from './evaluator';
export * from './backtest';
--- path: packages/risk/src/engine.ts
typescript
import type { Guardrail } from '@core/types';

export interface GuardrailEvalContext {
  trade: any;
  marketFeatures: any;
  portfolio: any;
}

export class GuardrailEngine {
  constructor(private guardrails: Guardrail[]) {}

  evaluate(context: GuardrailEvalContext): { pass: boolean; violations: string[] } {
    const violations: string[] = [];

    for (const rule of this.guardrails.filter((r) => r.enabled)) {
      const result = this.evaluateRule(rule, context);
      if (!result.pass) {
        violations.push(`${rule.rule_key}: ${result.reason}`);
      }
    }

    return {
      pass: violations.length === 0,
      violations,
    };
  }

  private evaluateRule(
    rule: Guardrail,
    context: GuardrailEvalContext
  ): { pass: boolean; reason: string } {
    // Parse rule text and evaluate against context
    // This is a simplified example - production would need a proper rule engine
    try {
      // Example rule: "if iv_rank < 0.3 then reject"
      if (rule.rule_text.includes('iv_rank')) {
        const threshold = parseFloat(rule.rule_text.match(/[\d.]+/)?.[0] || '0');
        if (context.marketFeatures.iv_rank < threshold) {
          return { pass: false, reason: `IV rank ${context.marketFeatures.iv_rank} below threshold ${threshold}` };
        }
      }

      // Example rule: "if days_to_earnings < 7 then reject"
      if (rule.rule_text.includes('days_to_earnings')) {
        const days = parseInt(rule.rule_text.match(/\d+/)?.[0] || '0');
        if (context.marketFeatures.days_to_earnings < days) {
          return { pass: false, reason: `Too close to earnings (${context.marketFeatures.days_to_earnings} days)` };
        }
      }

      return { pass: true, reason: '' };
    } catch (error) {
      console.error(`Error evaluating rule ${rule.rule_key}:`, error);
      return { pass: true, reason: 'Rule evaluation error' };
    }
  }
}
--- path: packages/risk/src/evaluator.ts
typescript
export interface BacktestResult {
  total_trades: number;
  win_rate: number;
  avg_return_pct: number;
  sharpe_ratio: number;
  max_drawdown: number;
  total_return: number;
}

export function evaluateGuardrail(
  historicalTrades: any[],
  guardrailRule: string
): BacktestResult {
  // Simulate applying guardrail to historical trades
  // Filter out trades that would have been blocked
  const filteredTrades = historicalTrades.filter((trade) => {
    return !wouldBlockTrade(trade, guardrailRule);
  });

  return calculateMetrics(filteredTrades);
}

function wouldBlockTrade(trade: any, rule: string): boolean {
  // Simplified rule evaluation
  // Production would need proper parsing and evaluation
  return false;
}

function calculateMetrics(trades: any[]): BacktestResult {
  const total_trades = trades.length;
  const winners = trades.filter((t) => t.pnl_pct > 0).length;
  const win_rate = winners / total_trades;

  const avg_return_pct =
    trades.reduce((sum, t) => sum + t.pnl_pct, 0) / total_trades;

  // Simplified Sharpe (assuming daily returns)
  const returns = trades.map((t) => t.pnl_pct);
  const mean = avg_return_pct;
  const variance =
    returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
  const std = Math.sqrt(variance);
  const sharpe_ratio = mean / (std || 1);

  // Simplified max drawdown
  let peak = 0;
  let max_drawdown = 0;
  let cumulative = 0;
  for (const trade of trades) {
    cumulative += trade.pnl_pct;
    peak = Math.max(peak, cumulative);
    max_drawdown = Math.min(max_drawdown, cumulative - peak);
  }

  const total_return = trades.reduce((sum, t) => sum + t.pnl_pct, 0);

  return {
    total_trades,
    win_rate,
    avg_return_pct,
    sharpe_ratio,
    max_drawdown,
    total_return,
  };
}
--- path: packages/risk/src/backtest.ts
typescript
export interface BacktestConfig {
  start_date: string;
  end_date: string;
  initial_capital: number;
  strategy_profile_id: string;
  guardrails: string[];
}

export async function runBacktest(config: BacktestConfig): Promise<any> {
  // Stub for backtesting engine
  // Production would load historical data and simulate trades
  console.log('Running backtest with config:', config);
  
  return {
    total_trades: 0,
    win_rate: 0,
    sharpe_ratio: 0,
    max_drawdown: 0,
    final_capital: config.initial_capital,
  };
}
--- path: packages/risk/profiles/credit_put_spread_core.yaml
yaml
name: Credit Put Spread - Core
description: Conservative credit put spreads on liquid underlyings with moderate IV

universe:
  - SPY
  - QQQ
  - IWM
  - DIA
  - AAPL
  - MSFT
  - NVDA

eligibility:
  min_price: 100
  iv_rank:
    min: 0.30
    max: 0.80
  earnings_window:
    min_days_before: 7
    hold_through_earnings: false
  liquidity:
    min_oi: 1000
    max_spread_bps: 50
  delta_range:
    short_leg: [0.15, 0.30]
    long_leg: [0.05, 0.15]
  dte:
    min: 21
    max: 45

sizing:
  per_trade_risk_pct: 1.0
  max_ticker_risk_pct: 5.0
  max_portfolio_delta: 100

exits:
  profit_target_pct: 50
  stop_loss_pct: 100
  time_exit_days: 21
  vol_exit_rule: "if iv_rank drops below 0.20, consider closing"

notes: >
  Core strategy for defined-risk premium collection.
  Target 50% profit in 21 days or less.
  Avoid earnings and low IV environments.
--- path: packages/risk/profiles/iron_condor_safe.yaml
yaml
name: Iron Condor - Safe
description: Wide iron condors on low-beta underlyings in elevated IV

universe:
  - SPY
  - IWM
  - TLT

eligibility:
  min_price: 50
  iv_rank:
    min: 0.40
    max: 0.90
  earnings_window:
    min_days_before: 10
    hold_through_earnings: false
  liquidity:
    min_oi: 2000
    max_spread_bps: 40
  delta_range:
    short_leg: [0.12, 0.20]
    long_leg: [0.05, 0.10]
  dte:
    min: 30
    max: 60

sizing:
  per_trade_risk_pct: 0.75
  max_ticker_risk_pct: 3.0
  max_portfolio_delta: 50

exits:
  profit_target_pct: 50
  stop_loss_pct: 150
  time_exit_days: 30
  vol_exit_rule: "if realized vol exceeds IV by 20%, exit"

notes: >
  Range-bound market strategy.
  Exit early if tested or IV collapses.
  Manage carefully near support/resistance.
--- path: packages/quantum/package.json
json
{
  "name": "@quantum/optimizer",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "test": "pytest test_optimizer.py"
  }
}
--- path: packages/quantum/requirements.txt
numpy>=1.24.0
scipy>=1.10.0
pytest>=7.4.0
--- path: packages/quantum/optimizer.py
python
"""
Quantum Portfolio Optimizer
Implements Mean-Variance (MV) and Mean-Variance-Skew (MVS) optimization.

Note: MVS is currently a stub that returns MV results.
"""

import numpy as np
from scipy.optimize import minimize
from typing import Dict, List, Tuple


def optimize(
    mode: str,
    expected_returns: List[float],
    covariance_matrix: List[List[float]],
    skewness: List[float] = None,
    constraints: Dict[str, float] = None,
    risk_aversion: float = 2.0,
) -> Dict:
    """
    Optimize portfolio weights.
    
    Args:
        mode: 'mv' for mean-variance, 'mvs' for mean-variance-skew
        expected_returns: Expected return for each asset
        covariance_matrix: Covariance matrix (n x n)
        skewness: Skewness coefficients (optional, for MVS)
        constraints: Dict with 'max_weight_per_asset', 'sector_cap', etc.
        risk_aversion: Lambda parameter (default 2.0)
    
    Returns:
        Dict with weights, estimated sharpe, and max drawdown
    """
    n_assets = len(expected_returns)
    
    # Convert to numpy arrays
    mu = np.array(expected_returns)
    Sigma = np.array(covariance_matrix)
    
    # Default constraints
    if constraints is None:
        constraints = {
            'max_weight_per_asset': 0.25,
            'sector_cap': 0.35,
        }
    
    max_weight = constraints.get('max_weight_per_asset', 0.25)
    
    # Objective function (MV for now)
    def objective(w):
        portfolio_return = np.dot(mu, w)
        portfolio_variance = np.dot(w, np.dot(Sigma, w))
        return -(portfolio_return - risk_aversion * portfolio_variance)
    
    # Constraints
    cons = [
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},  # Weights sum to 1
    ]
    
    # Bounds
    bounds = [(0, max_weight) for _ in range(n_assets)]
    
    # Initial guess
    w0 = np.ones(n_assets) / n_assets
    
    # Optimize
    result = minimize(
        objective,
        w0,
        method='SLSQP',
        bounds=bounds,
        constraints=cons,
    )
    
    if not result.success:
        raise ValueError(f"Optimization failed: {result.message}")
    
    weights = result.x
    
    # Calculate metrics
    portfolio_return = np.dot(mu, weights)
    portfolio_std = np.sqrt(np.dot(weights, np.dot(Sigma, weights)))
    sharpe_est = portfolio_return / (portfolio_std + 1e-10)
    
    # Simplified max drawdown estimate
    maxDD_est = -2.0 * portfolio_std  # Rule of thumb
    
    # Convert weights to dict
    weight_dict = {f"asset_{i}": float(w) for i, w in enumerate(weights)}
    
    return {
        'weights': weight_dict,
        'sharpe_est': float(sharpe_est),
        'maxDD_est': float(maxDD_est),
        'portfolio_return': float(portfolio_return),
        'portfolio_std': float(portfolio_std),
    }


def optimize_mv(
    expected_returns: List[float],
    covariance_matrix: List[List[float]],
    constraints: Dict[str, float] = None,
    risk_aversion: float = 2.0,
) -> Dict:
    """Mean-Variance optimization."""
    return optimize('mv', expected_returns, covariance_matrix, None, constraints, risk_aversion)


def optimize_mvs(
    expected_returns: List[float],
    covariance_matrix: List[List[float]],
    skewness: List[float],
    constraints: Dict[str, float] = None,
    risk_aversion: float = 2.0,
    skew_preference: float = 0.5,
) -> Dict:
    """
    Mean-Variance-Skew optimization.
    
    Note: Currently returns MV results as placeholder.
    Full MVS implementation would add skew term to objective.
    """
    # TODO: Implement full MVS with skew term
    # For now, return MV results
    return optimize('mv', expected_returns, covariance_matrix, None, constraints, risk_aversion)


if __name__ == '__main__':
    # Example usage
    returns = [0.10, 0.12, 0.08, 0.15]
    cov = [
        [0.04, 0.01, 0.01, 0.02],
        [0.01, 0.06, 0.02, 0.01],
        [0.01, 0.02, 0.03, 0.01],
        [0.02, 0.01, 0.01, 0.08],
    ]
    
    result = optimize_mv(returns, cov)
    print("MV Optimization Result:")
    print(f"Weights: {result['weights']}")
    print(f"Sharpe: {result['sharpe_est']:.2f}")
    print(f"Max DD: {result['maxDD_est']:.2%}")
--- path: packages/quantum/test_optimizer.py
python
import pytest
import numpy as np
from optimizer import optimize_mv, optimize_mvs


def test_mv_optimization():
    """Test mean-variance optimization."""
    returns = [0.10, 0.12, 0.08, 0.15]
    cov = [
        [0.04, 0.01, 0.01, 0.02],
        [0.01, 0.06, 0.02, 0.01],
        [0.01, 0.02, 0.03, 0.01],
        [0.02, 0.01, 0.01, 0.08],
    ]
    
    result = optimize_mv(returns, cov)
    
    assert 'weights' in result
    assert 'sharpe_est' in result
    assert 'maxDD_est' in result
    
    # Weights should sum to 1
    weights = list(result['weights'].values())
    assert abs(sum(weights) - 1.0) < 1e-6
    
    # All weights should be non-negative
    assert all(w >= 0 for w in weights)
    
    # No weight should exceed max_weight (default 0.25)
    assert all(w <= 0.25 + 1e-6 for w in weights)


def test_weight_constraints():
    """Test that weight constraints are respected."""
    returns = [0.15, 0.15, 0.15, 0.15]  # Equal returns
    cov = np.eye(4) * 0.04  # Uncorrelated, equal variance
    
    constraints = {'max_weight_per_asset': 0.20}
    result = optimize_mv(returns, cov.tolist(), constraints)
    
    weights = list(result['weights'].values())
    assert all(w <= 0.20 + 1e-6 for w in weights)


def test_mvs_placeholder():
    """Test MVS optimization (currently returns MV)."""
    returns = [0.10, 0.12, 0.08]
    cov = [
        [0.04, 0.01, 0.01],
        [0.01, 0.06, 0.02],
        [0.01, 0.02, 0.03],
    ]
    skewness = [0.5, -0.3, 0.2]
    
    result = optimize_mvs(returns, cov, skewness)
    
    assert 'weights' in result
    assert 'sharpe_est' in result
--- path: infra/supabase/config.toml
toml
# Supabase local config

[api]
port = 54321
schemas = ["public"]
max_rows = 1000

[db]
port = 54322

[studio]
port = 54323
--- path: infra/supabase/migrations/20240101000000_initial_schema.sql
sql
-- Initial schema for options trading companion

-- Users table (managed by Supabase Auth)
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Broker connections
CREATE TABLE connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  provider TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('active', 'inactive', 'error')),
  oauth_metadata JSONB,
  linked_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_connections_user_id ON connections(user_id);

-- Positions
CREATE TABLE positions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  symbol TEXT NOT NULL,
  qty NUMERIC NOT NULL,
  avg_price NUMERIC NOT NULL,
  greek_delta NUMERIC,
  greek_theta NUMERIC,
  greek_vega NUMERIC,
  iv_rank NUMERIC,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_positions_user_id ON positions(user_id);
CREATE INDEX idx_positions_symbol ON positions(symbol);

-- Trades
CREATE TABLE trades (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  symbol TEXT NOT NULL,
  strategy_id TEXT NOT NULL,
  open_ts TIMESTAMPTZ NOT NULL,
  close_ts TIMESTAMPTZ,
  pnl_pct NUMERIC,
  legs_json JSONB NOT NULL,
  thesis_json JSONB,
  market_snapshot_json JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_trades_user_id ON trades(user_id);
CREATE INDEX idx_trades_symbol ON trades(symbol);
CREATE INDEX idx_trades_open_ts ON trades(open_ts);

-- Guardrail rules
CREATE TABLE rules_guardrails (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  rule_key TEXT NOT NULL,
  rule_text TEXT NOT NULL,
  priority TEXT NOT NULL CHECK (priority IN ('low', 'medium', 'high')),
  enabled BOOLEAN DEFAULT TRUE,
  added_ts TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, rule_key)
);

CREATE INDEX idx_guardrails_user_id ON rules_guardrails(user_id);
CREATE INDEX idx_guardrails_enabled ON rules_guardrails(enabled);

-- Loss reviews
CREATE TABLE loss_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  trade_id UUID NOT NULL REFERENCES trades(id) ON DELETE CASCADE,
  root_cause TEXT NOT NULL,
  evidence_json JSONB NOT NULL,
  recommended_rule_json JSONB NOT NULL,
  confidence NUMERIC NOT NULL CHECK (confidence >= 0 AND confidence <= 1),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_loss_reviews_trade_id ON loss_reviews(trade_id);
CREATE INDEX idx_loss_reviews_created_at ON loss_reviews(created_at);

-- Alerts
CREATE TABLE alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  payload_json JSONB NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('unread', 'read', 'archived')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_alerts_user_id ON alerts(user_id);
CREATE INDEX idx_alerts_status ON alerts(status);

-- Settings
CREATE TABLE settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  quantum_mode BOOLEAN DEFAULT FALSE,
  llm_budget_cents INT DEFAULT 1000,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_settings_user_id ON settings(user_id);

-- Market features (ring buffer / time-series)
CREATE TABLE market_features (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  symbol TEXT NOT NULL,
  spot NUMERIC NOT NULL,
  spread_bps NUMERIC,
  iv_rank NUMERIC,
  iv_percentile NUMERIC,
  rv_1m NUMERIC,
  rv_5m NUMERIC,
  rv_15m NUMERIC,
  vix_level NUMERIC,
  spx_trend NUMERIC,
  smile_slope NUMERIC,
  term_slope NUMERIC,
  days_to_earnings INT,
  oi_median NUMERIC,
  spread_bps_median NUMERIC,
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_market_features_symbol ON market_features(symbol);
CREATE INDEX idx_market_features_timestamp ON market_features(timestamp);

-- LLM job queue (optional, for tracking scout jobs)
CREATE TABLE llm_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  job_type TEXT NOT NULL CHECK (job_type IN ('trade_scout', 'candidate_check', 'loss_review')),
  status TEXT NOT NULL CHECK (status IN ('pending', 'running', 'completed', 'failed')),
  input_json JSONB NOT NULL,
  output_json JSONB,
  cost_cents INT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

CREATE INDEX idx_llm_jobs_user_id ON llm_jobs(user_id);
CREATE INDEX idx_llm_jobs_status ON llm_jobs(status);
--- path: infra/supabase/migrations/20240101000001_rls_policies.sql
sql
-- Row Level Security policies

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE trades ENABLE ROW LEVEL SECURITY;
ALTER TABLE rules_guardrails ENABLE ROW LEVEL SECURITY;
ALTER TABLE loss_reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE llm_jobs ENABLE ROW LEVEL SECURITY;

-- Users policies
CREATE POLICY "Users can view own profile"
  ON users FOR SELECT
  USING (auth.uid() = id);

-- Connections policies
CREATE POLICY "Users can view own connections"
  ON connections FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update own connections"
  ON connections FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own connections"
  ON connections FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Positions policies
CREATE POLICY "Users can view own positions"
  ON positions FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage positions"
  ON positions FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Trades policies
CREATE POLICY "Users can view own trades"
  ON trades FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own trades"
  ON trades FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Service role can manage trades"
  ON trades FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Guardrails policies
CREATE POLICY "Users can view own guardrails"
  ON rules_guardrails FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own guardrails"
  ON rules_guardrails FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own guardrails"
  ON rules_guardrails FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage guardrails"
  ON rules_guardrails FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Loss reviews policies
CREATE POLICY "Users can view own loss reviews"
  ON loss_reviews FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM trades
    WHERE trades.id = loss_reviews.trade_id
    AND trades.user_id = auth.uid()
  ));

CREATE POLICY "Service role can manage loss reviews"
  ON loss_reviews FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Alerts policies
CREATE POLICY "Users can view own alerts"
  ON alerts FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update own alerts"
  ON alerts FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage alerts"
  ON alerts FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Settings policies
CREATE POLICY "Users can view own settings"
  ON settings FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update own settings"
  ON settings FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own settings"
  ON settings FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- LLM jobs policies
CREATE POLICY "Users can view own jobs"
  ON llm_jobs FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage jobs"
  ON llm_jobs FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Market features: read-only for all authenticated users
ALTER TABLE market_features ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Authenticated users can view market features"
  ON market_features FOR SELECT
  USING (auth.role() = 'authenticated');

CREATE POLICY "Service role can manage market features"
  ON market_features FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');
--- path: infra/supabase/migrations/20240101000002_seed_data.sql
sql
-- Seed data for development

-- Create test user (if not using Supabase Auth UI)
-- INSERT INTO auth.users (id, email, encrypted_password, email_confirmed_at, created_at)
-- VALUES (
--   gen_random_uuid(),
--   'test@example.com',
--   crypt('password123', gen_salt('bf')),
--   NOW(),
--   NOW()
-- );

-- Sample market features
INSERT INTO market_features (symbol, spot, spread_bps, iv_rank, iv_percentile, rv_1m, vix_level, days_to_earnings, oi_median)
VALUES
  ('SPY', 480.50, 5, 0.45, 0.48, 0.12, 15.5, 45, 5000),
  ('QQQ', 420.30, 8, 0.52, 0.55, 0.18, 15.5, 30, 3500),
  ('IWM', 205.80, 12, 0.38, 0.40, 0.15, 15.5, 60, 2000);
--- path: infra/vercel/vercel.json
json
{
  "buildCommand": "pnpm build",
  "devCommand": "pnpm --filter @app/web dev",
  "installCommand": "pnpm install",
  "framework": "nextjs",
  "regions": ["iad1"],
  "env": {
    "NEXT_PUBLIC_SUPABASE_URL": "@supabase-url",
    "SUPABASE_ANON_KEY": "@supabase-anon-key",
    "ANTHROPIC_API_KEY": "@anthropic-api-key"
  }
}
--- path: infra/scripts/bootstrap.sh
bash
#!/bin/bash
set -e

echo "🚀 Bootstrapping Options Trading Companion..."

# Check prerequisites
command -v node >/dev/null 2>&1 || { echo "❌ Node.js is required"; exit 1; }
command -v pnpm >/dev/null 2>&1 || { echo "❌ pnpm is required. Install: npm i -g pnpm"; exit 1; }
command -v supabase >/dev/null 2>&1 || { echo "⚠️  Supabase CLI not found. Install: brew install supabase/tap/supabase"; }

# Install dependencies
echo "📦 Installing dependencies..."
pnpm install

# Check environment
echo "🔍 Checking environment..."
if [ ! -f .env ]; then
  echo "⚠️  .env file not found. Copying from .env.example..."
  cp .env.example .env
  echo "✏️  Please edit .env with your API keys"
fi

# Setup Python environment for quantum package
echo "🐍 Setting up Python environment..."
cd packages/quantum
if [ ! -d "venv" ]; then
  python3 -m venv venv
fi
source venv/bin/activate
pip install -r requirements.txt
deactivate
cd ../..

echo "✅ Bootstrap complete!"
echo ""
echo "Next steps:"
echo "1. Edit .env with your API keys"
echo "2. Run 'supabase start' or link to existing project"
echo "3. Run 'pnpm dev' to start development servers"
--- path: infra/scripts/env-check.ts
typescript
#!/usr/bin/env tsx

import * as fs from 'fs';
import * as path from 'path';

const requiredVars = [
  'ANTHROPIC_API_KEY',
  'NEXT_PUBLIC_SUPABASE_URL',
  'SUPABASE_ANON_KEY',
  'SUPABASE_SERVICE_ROLE_KEY',
];

const optionalVars = [
  'SNAPTRADE_API_KEY',
  'MARKETDATA_API_KEY',
  'CF_ACCOUNT_ID',
  'CF_API_TOKEN',
];

function checkEnv() {
  const envPath = path.join(process.cwd(), '.env');
  
  if (!fs.existsSync(envPath)) {
    console.error('❌ .env file not found');
    console.log('Run: cp .env.example .env');
    process.exit(1);
  }

  const envContent = fs.readFileSync(envPath, 'utf-8');
  const envVars = new Map<string, string>();

  envContent.split('\n').forEach((line) => {
    const match = line.match(/^([^=]+)=(.*)$/);
    if (match) {
      envVars.set(match[1].trim(), match[2].trim());
    }
  });

  let allOk = true;

  console.log('🔍 Checking required environment variables...\n');

  requiredVars.forEach((varName) => {
    const value = envVars.get(varName);
    if (!value || value === 'your-key-here' || value.includes('xxx')) {
      console.log(`❌ ${varName} - Missing or placeholder`);
      allOk = false;
    } else {
      console.log(`✅ ${varName}`);
    }
  });

  console.log('\n🔍 Checking optional environment variables...\n');

  optionalVars.forEach((varName) => {
    const value = envVars.get(varName);
    if (!value || value === 'your-key-here' || value.includes('xxx')) {
      console.log(`⚠️  ${varName} - Not configured (optional)`);
    } else {
      console.log(`✅ ${varName}`);
    }
  });

  console.log('');

  if (!allOk) {
    console.error('❌ Some required variables are missing');
    process.exit(1);
  }

  console.log('✅ All required environment variables are set');
}

checkEnv();
--- path: infra/scripts/dev-run.sh
bash
#!/bin/bash
set -e

echo "🚀 Starting development environment..."

# Check if Supabase is running
if ! supabase status >/dev/null 2>&1; then
  echo "⚠️  Supabase not running. Starting..."
  supabase start
fi

# Start all services in parallel
echo "Starting services..."

# Cloudflare Worker (optional, comment out if not needed yet)
# pnpm --filter @app/worker dev &

# Next.js app
pnpm --filter @app/web dev &

wait
## RUN LOCALLY
bash
# 1. Clone and install
git clone <your-repo>
cd options-trading-companion
bash infra/scripts/bootstrap.sh

# 2. Configure environment
# Edit .env with your API keys:
# - ANTHROPIC_API_KEY (required)
# - NEXT_PUBLIC_SUPABASE_URL (required)
# - SUPABASE_ANON_KEY (required)
# - SUPABASE_SERVICE_ROLE_KEY (required)
# - Other optional keys as needed

# 3. Check environment
pnpm env-check

# 4. Start Supabase (local)
supabase start
# OR link to existing project:
# supabase link --project-ref your-project-ref

# 5. Apply migrations
supabase db push

# 6. Start Cloudflare Worker (development)
cd apps/worker
npx wrangler dev
# Keep this terminal open

# 7. Start Next.js (in new terminal)
cd ../..
pnpm --filter @app/web dev

# 8. Access the app
# Open http://localhost:3000
# Supabase Studio: http://localhost:54323

# Optional: Run Python quantum tests
cd packages/quantum
source venv/bin/activate
pytest test_optimizer.py
**Production Deployment:** 1. **Vercel (Frontend)**
bash
   vercel --prod
2. **Cloudflare Workers (Cron/Webhooks)**
bash
   cd apps/worker
   wrangler deploy
3. **Supabase (Database)** - Link to production project - Apply migrations: supabase db push --linked **Key Files to Review:** - packages/core/src/gate.ts - Gating logic - packages/ai/src/prompts.ts - LLM prompts - packages/core/src/schemas.ts - Zod validation schemas - infra/supabase/migrations/ - Database schema and RLS **Acceptance Tests:** Run these manually after setup: 1. Sign up → Connect broker (mock) → Verify positions load 2. Navigate to Compose → Enter trade → Verify gating runs 3. Close a losing trade → Verify loss review generates guardrail 4. Enable quantum mode in Settings → Verify comparison appears